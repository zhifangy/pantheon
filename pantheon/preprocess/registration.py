#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import annotations
from typing import Optional, Literal
from pathlib import Path
import shutil
import tempfile

from ..image.gifti import sanitize_gii_metadata
from ..utils.validation import parse_hemi
from ..utils.shell import run_cmd
from ..utils.typing import PathLike


def warp_native_sphere_to_fsLR(
    in_sphere_file: PathLike,
    proj_sphere_file: PathLike,
    unproj_sphere_file: PathLike,
    out_file: PathLike,
) -> Path:
    """Deforms fsnative sphere in fsaverage space to fsLR space.

    This function warps sphere mesh in native space to fsLR space. The
    sphere mesh density remains the same after warpping. It relies on
    the sphere in fsaverage space generated by FreeSurfer.

    Args:
        in_sphere_file: Native sphere mesh file in fsaverage space
            (generated by FreeSurfer).
        proj_sphere_file: Standard fsaverage sphere mesh file.
        unproj_sphere_file: fsaverage sphere mesh file in fsLR space.
        out_file: Output native sphere mesh file.

    Returns:
        A sphere mesh file in fsLR space with native mesh density.
    """

    print(f"Warpping native sphere to fsLR space: {in_sphere_file} ...", flush=True)
    run_cmd(
        "wb_command -disable-provenance -surface-sphere-project-unproject "
        f"{in_sphere_file} {proj_sphere_file} {unproj_sphere_file} {out_file}"
    )
    # Cleanup metadata
    _ = sanitize_gii_metadata(out_file, out_file, da_meta={"Name": ""})

    return Path(out_file)


def calc_native_to_fsLR_registration_MSMSulc(
    hemi: Literal["L", "R"],
    in_sphere_file: PathLike,
    fs_aligned_sphere_file: PathLike,
    in_sulc_file: PathLike,
    ref_sphere_file: PathLike,
    ref_sulc_file: PathLike,
    out_file: PathLike,
    msm_config_file: PathLike,
    debug: bool = False,
):
    """Calculates registration between native and fsLR space.

    This function aligns a sphere mesh file in native space to fsLR
    space through MSMSulc method. The mesh density remains the same as
    the native sphere mesh. Usually, the result of this method is
    slightly different from (better than) the FreeSurfer's result.
    The fs_aligned_sphere_file is used for initializing the MSMSulc
    registration.

    Args:
        hemi: Brain hemisphere.
        in_sphere_file: Native sphere mesh file in native space.
        fs_aligned_sphere_file: Native sphere mesh file in fsLR space.
            Usually it is generated by function
            'warp_native_sphere_to_fsLR'.
        in_sulc_file: Metric sulc file in native space.
        ref_sphere_file: Standard fsLR sphere file.
        ref_sulc_file: Standard metric sulc file in fsLR space.
        out_file: Output native sphere mesh file.
        msm_config_file: MSMSulc configuration file.
        debug: If true, output intermediate files.

    Returns:
        A sphere mesh file in fsLR space with native mesh density.
    """

    # Parse hemisphere
    hemi, structure = parse_hemi(hemi)

    with tempfile.TemporaryDirectory() as tmp_dir:

        # Calculate affine transformation to align fsnative and fsLR sphere
        print(f"Aligning fsnative and fsLR sphere (affine): {in_sphere_file} ... ", flush=True)
        affine_file = Path(tmp_dir, f"hemi-{hemi}_from-fsnative_to-fsLR_mode-image_xfm.mat")
        run_cmd(
            "wb_command -disable-provenance -surface-affine-regression "
            f"{in_sphere_file} {fs_aligned_sphere_file} {affine_file}"
        )
        # Apply affine transformation to input sphere
        aligned_sphere_file = Path(
            tmp_dir, f"hemi-{hemi}_space-fsnative_den-fsnative_desc-fsLRrot_sphere.surf.gii"
        )
        run_cmd(
            "wb_command -disable-provenance -surface-apply-affine "
            f"{in_sphere_file} {affine_file} {aligned_sphere_file}"
        )
        # Change sphere radius
        run_cmd(
            "wb_command -disable-provenance -logging SEVERE -surface-modify-sphere "
            f"{aligned_sphere_file} 100 {aligned_sphere_file}"
        )
        # Cleanup metadata
        _ = sanitize_gii_metadata(aligned_sphere_file, aligned_sphere_file, da_meta={"Name": ""})

        # Run MSMSulc registration
        print(f"Running MSMSulc registration to fsLR space:  {in_sphere_file} ...", flush=True)
        run_cmd(
            f"msm --conf={msm_config_file} --inmesh={aligned_sphere_file} "
            f"--refmesh={ref_sphere_file} --indata={in_sulc_file} "
            f"--refdata={ref_sulc_file} --out={tmp_dir}/{hemi}."
        )
        # Copy outputs and set GIFTI metadata
        shutil.copy(Path(tmp_dir).joinpath(f"{hemi}.sphere.reg.surf.gii"), out_file)
        run_cmd(f"wb_command -disable-provenance -set-structure {out_file} {structure}")
        # Cleanup metadata
        _ = sanitize_gii_metadata(out_file, out_file, da_meta={"Name": ""})

        # Output registration files if requested
        if debug:
            out_dir = Path(out_file).parent
            shutil.copy(msm_config_file, tmp_dir)
            shutil.copytree(tmp_dir, out_dir.joinpath("temp_MSMSulc"), dirs_exist_ok=True)

    return Path(out_file)


def calc_registration_distortion(
    src_sphere_file: PathLike,
    warpped_sphere_file: PathLike,
    out_file: PathLike,
    metric_id: Literal["Areal", "Edge", "StrainJ", "StrainR"],
    gifti_map_name: Optional[str] = None,
) -> Path:
    """Calculates distortion map of warpped surface sphere.

    Args:
        src_sphere_file: The orginal surface sphere file.
        wappped_sphere_file: Warpped surface sphere file.
        out_file: Output distortion map file.
        metric_id: Distortion metric.
        gifti_map_name: Map name of distortion file.

    Returns:
        A registration distortion GIFTI file.

    Raises:
        ValueError: Unrecognized distortion metric_id.
    """

    # Parse distortion metric name
    if metric_id not in ["Areal", "Edge", "StrainJ", "StrainR"]:
        raise ValueError(
            f"Unrecognized distortion metric {metric_id}. Valid: Areal, Edge, StrainJ, StrainR"
        )

    print(f"Calculating registration {metric_id} distortion: {src_sphere_file} ...", flush=True)
    # Areal
    if metric_id == "Areal":
        run_cmd(
            "wb_command -disable-provenance -surface-distortion "
            f"{src_sphere_file} {warpped_sphere_file} {out_file}"
        )
    # Edge
    if metric_id == "Edge":
        run_cmd(
            "wb_command -disable-provenance -surface-distortion "
            f"{src_sphere_file} {warpped_sphere_file} {out_file} -edge-method"
        )
    # StrainJ, StrainR
    if metric_id in ["StrainJ", "StrainR"]:
        # map column in the strain file
        col_id = 1 if metric_id == "StrainJ" else 2
        with tempfile.TemporaryDirectory() as tmp_dir:
            strain_file = Path(tmp_dir).joinpath("Strain_distortion.shape.gii")
            run_cmd(
                "wb_command -disable-provenance -surface-distortion "
                f"{src_sphere_file} {warpped_sphere_file} {strain_file} -local-affine-method"
            )
            run_cmd(
                "wb_command -disable-provenance -metric-merge "
                f"{out_file} -metric {strain_file} -column {col_id}"
            )
            run_cmd(
                "wb_command -disable-provenance -metric-math ln(var)/ln(2) "
                f"{out_file} -var var {out_file}"
            )

    # Set GIFTI metadata
    palette_mode = "MODE_USER_SCALE"
    palette_options = (
        "-pos-user 0 1 -neg-user 0 -1 -interpolate true -palette-name ROY-BIG-BL "
        "-disp-pos true -disp-neg true -disp-zero false"
    )
    run_cmd(
        "wb_command -disable-provenance -metric-palette "
        f"{out_file} {palette_mode} {palette_options}"
    )
    gifti_map_name = f"distortion_{metric_id}" if gifti_map_name is None else gifti_map_name
    run_cmd(f"wb_command -disable-provenance -set-map-names {out_file} -map 1 {gifti_map_name}")

    # Cleanup metadata
    _ = sanitize_gii_metadata(out_file, out_file)

    return Path(out_file)
